//@ sourceMappingURL=form_generator.map
// Generated by CoffeeScript 1.6.1
(function() {
  var FieldCollection, FieldModel, confirmation, documentTypes, fieldTypes, spinner, typeToParam,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.Forms = {};

  confirmation = require('bmcmahen-confirmation');

  spinner = require('bmcmahen-canvas-loading-animation');

  documentTypes = ['Event', 'Idea', 'Institution', 'Person', 'Place', 'Publication'];

  typeToParam = {
    event: 'events',
    idea: 'ideas',
    institution: 'institutions',
    person: 'people',
    place: 'places',
    publication: 'publications'
  };

  fieldTypes = {
    required: function() {
      return {
        title: {
          widget: "text",
          label: "Title",
          required: true
        },
        type: {
          widget: "select",
          label: "Document Type",
          options: documentTypes
        },
        shortDescription: {
          widget: "text",
          label: "Short Description",
          required: true
        },
        fullDescription: {
          widget: "textarea",
          label: "Full Description",
          required: true
        },
        image: {
          widget: "image",
          label: "Image"
        },
        resources: {
          widget: "formset",
          label: "Link",
          fields: [
            {
              widget: "text",
              label: "Resource"
            }
          ]
        },
        prods: {
          widget: "checkbox",
          fields: [
            {
              timeline: {
                widget: "checkbox",
                label: "Timeline",
                value: ""
              },
              heroes: {
                widget: "checkbox",
                label: "Heroes and Villains",
                value: ""
              }
            }
          ]
        }
      };
    },
    event: function() {
      return {
        date: {
          widget: "text",
          label: "Date",
          className: "date",
          helpText: "Format: MM/DD/YYYY"
        }
      };
    },
    person: function() {
      return {
        dateOfBirth: {
          widget: "text",
          label: "Date of Birth",
          className: "dateOfBirth"
        },
        dateOfDeath: {
          widget: "text",
          label: "Date of Death",
          className: "dateOfDeath"
        }
      };
    },
    publication: function() {
      return {
        yearOfPublication: {
          widget: "text",
          label: "Year of Publication"
        },
        monthOfPublication: {
          widget: "text",
          label: "Month of Publication"
        },
        author: {
          widget: "text",
          label: "Author"
        },
        publisher: {
          widget: "text",
          label: "Publisher"
        }
      };
    },
    timeline: function() {
      return {
        date: {
          widget: "text",
          className: "date",
          helpText: "Format: MM/DD/YYYY"
        },
        startDate: {
          widget: "text",
          label: "Date Range (Start Date)",
          helpText: "If you want this entry to appear as a date range, use this field. Format: MM/DD/YYYY."
        },
        endDate: {
          widget: "text",
          label: "Date Range (End Date)",
          helpText: "If you want this entry to appear as a date range, use this field. Format: MM/DD/YYYY."
        }
      };
    },
    heroes: function() {
      return {
        heroQuote: {
          widget: "textarea",
          label: "Hero Quote",
          className: "hero quote"
        },
        heroQuoteSource: {
          widget: "text",
          label: "Hero Quote Citation",
          className: "citation"
        },
        villainQuote: {
          widget: "textarea",
          label: "Villain Quote",
          className: "villain quote"
        },
        villainQuoteSource: {
          widget: "text",
          label: "Villain Quote Citation",
          className: "citation"
        },
        ambiQuote: {
          widget: "textarea",
          label: "Ambiguous Quote",
          className: "ambiquote quote"
        },
        ambiQuoteSource: {
          widget: "text",
          label: "Ambiguous Quote Source",
          className: "citation"
        }
      };
    }
  };

  FieldModel = (function(_super) {

    __extends(FieldModel, _super);

    function FieldModel() {
      return FieldModel.__super__.constructor.apply(this, arguments);
    }

    FieldModel.prototype.validateModel = function(attrs, options) {
      if (attrs == null) {
        attrs = this.toJson();
      }
      if (attrs.required) {
        if ((attrs.value == null) || attrs.value === '') {
          this.set('error', 'This field is required');
          return true;
        }
        if (this.has('error')) {
          return this.unset('error');
        }
      }
    };

    return FieldModel;

  })(Backbone.Model);

  FieldCollection = (function(_super) {

    __extends(FieldCollection, _super);

    function FieldCollection() {
      return FieldCollection.__super__.constructor.apply(this, arguments);
    }

    FieldCollection.prototype.model = FieldModel;

    FieldCollection.prototype.saveCollection = function() {
      var json;
      json = {};
      this.each(function(model) {
        var val;
        val = model.get('value');
        if (val != null) {
          return json[model.get('name')] = model.get('value');
        }
      });
      return this.formModel.setAndSave(json);
    };

    FieldCollection.prototype.generateFieldModels = function() {
      var attr, field, fields, key, prod, prodKey, _ref;
      attr = this.formModel.toJSON();
      this.type = attr.type;
      this.prods = attr.prods;
      fields = this.determineRequiredFields({
        type: attr.type,
        prods: attr.prods
      });
      for (key in fields) {
        field = fields[key];
        field.name = key;
        if (key === 'prods') {
          _ref = field.fields[0];
          for (prod in _ref) {
            prodKey = _ref[prod];
            if (_.contains(attr.prods, prodKey)) {
              prod.value = 'checked';
            }
            prod.name = prodKey;
          }
        } else if (field.widget === 'fieldset') {
          field.subfields = _.map(field.fields, function(subfield, key) {
            subfield.name = key;
            return new FieldModel(subfield);
          });
        } else if (attr[key] == null) {
          field.value = attr[key];
        }
        this.add(field);
      }
      return this;
    };

    return FieldCollection;

  })(Backbone.Collection);

}).call(this);
